
Imprime code assembleur contenu dans svc_demo.elf avec objdump
arm-none-eabi-objdump -S --disassemble svc_demo.elf

svc_demo.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <myvectors>:
   0:	00 50 00 20 91 02 00 00 31 01 00 00 41 01 00 00     .P. ....1...A...
  10:	51 01 00 00 61 01 00 00 71 01 00 00 81 02 00 00     Q...a...q.......
  20:	81 02 00 00 81 02 00 00 81 02 00 00 15 03 00 00     ................
  30:	81 02 00 00 81 02 00 00 91 01 00 00 89 03 00 00     ................
  40:	b1 01 00 00 c1 01 00 00 e1 01 00 00 d1 01 00 00     ................
  50:	f1 01 00 00 01 02 00 00 11 02 00 00 21 02 00 00     ............!...
  60:	31 02 00 00 41 02 00 00 51 02 00 00 61 02 00 00     1...A...Q...a...
  70:	71 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     q...............
  80:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  90:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  a0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  b0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  c0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  d0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  e0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
  f0:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
 100:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
 110:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................
 120:	81 02 00 00 81 02 00 00 81 02 00 00 81 02 00 00     ................

00000130 <NMI_handler>:
// réinitialise le µC
// L'attribut (weak) permet de les remplacer par une fonction du même nom
// sans avoir à modifier le fichier startup.c

// core exceptions
_default_handler(NMI_handler) // 2
 130:	4a01      	ldr	r2, [pc, #4]	; (138 <NMI_handler+0x8>)
 132:	4b02      	ldr	r3, [pc, #8]	; (13c <NMI_handler+0xc>)
 134:	601a      	str	r2, [r3, #0]
 136:	bf00      	nop
 138:	05fa0004 	.word	0x05fa0004
 13c:	e000ed0c 	.word	0xe000ed0c

00000140 <HARD_FAULT_handler>:
_default_handler(HARD_FAULT_handler) // 3
 140:	4a01      	ldr	r2, [pc, #4]	; (148 <HARD_FAULT_handler+0x8>)
 142:	4b02      	ldr	r3, [pc, #8]	; (14c <HARD_FAULT_handler+0xc>)
 144:	601a      	str	r2, [r3, #0]
 146:	bf00      	nop
 148:	05fa0004 	.word	0x05fa0004
 14c:	e000ed0c 	.word	0xe000ed0c

00000150 <MM_FAULT_handler>:
_default_handler(MM_FAULT_handler)  // 4
 150:	4a01      	ldr	r2, [pc, #4]	; (158 <MM_FAULT_handler+0x8>)
 152:	4b02      	ldr	r3, [pc, #8]	; (15c <MM_FAULT_handler+0xc>)
 154:	601a      	str	r2, [r3, #0]
 156:	bf00      	nop
 158:	05fa0004 	.word	0x05fa0004
 15c:	e000ed0c 	.word	0xe000ed0c

00000160 <BUS_FAULT_handler>:
_default_handler(BUS_FAULT_handler) // 5
 160:	4a01      	ldr	r2, [pc, #4]	; (168 <BUS_FAULT_handler+0x8>)
 162:	4b02      	ldr	r3, [pc, #8]	; (16c <BUS_FAULT_handler+0xc>)
 164:	601a      	str	r2, [r3, #0]
 166:	bf00      	nop
 168:	05fa0004 	.word	0x05fa0004
 16c:	e000ed0c 	.word	0xe000ed0c

00000170 <USAGE_FAULT_handler>:
_default_handler(USAGE_FAULT_handler) // 6
 170:	4a01      	ldr	r2, [pc, #4]	; (178 <USAGE_FAULT_handler+0x8>)
 172:	4b02      	ldr	r3, [pc, #8]	; (17c <USAGE_FAULT_handler+0xc>)
 174:	601a      	str	r2, [r3, #0]
 176:	bf00      	nop
 178:	05fa0004 	.word	0x05fa0004
 17c:	e000ed0c 	.word	0xe000ed0c
_default_handler(SVC_handler) // 11
 180:	4a01      	ldr	r2, [pc, #4]	; (188 <USAGE_FAULT_handler+0x18>)
 182:	4b02      	ldr	r3, [pc, #8]	; (18c <USAGE_FAULT_handler+0x1c>)
 184:	601a      	str	r2, [r3, #0]
 186:	bf00      	nop
 188:	05fa0004 	.word	0x05fa0004
 18c:	e000ed0c 	.word	0xe000ed0c

00000190 <PENDSV_handler>:
_default_handler(PENDSV_handler) // 14
 190:	4a01      	ldr	r2, [pc, #4]	; (198 <PENDSV_handler+0x8>)
 192:	4b02      	ldr	r3, [pc, #8]	; (19c <PENDSV_handler+0xc>)
 194:	601a      	str	r2, [r3, #0]
 196:	bf00      	nop
 198:	05fa0004 	.word	0x05fa0004
 19c:	e000ed0c 	.word	0xe000ed0c
_default_handler(STK_handler) // 15
 1a0:	4a01      	ldr	r2, [pc, #4]	; (1a8 <PENDSV_handler+0x18>)
 1a2:	4b02      	ldr	r3, [pc, #8]	; (1ac <PENDSV_handler+0x1c>)
 1a4:	601a      	str	r2, [r3, #0]
 1a6:	bf00      	nop
 1a8:	05fa0004 	.word	0x05fa0004
 1ac:	e000ed0c 	.word	0xe000ed0c

000001b0 <WWDG_handler>:

// IRQ
_default_handler(WWDG_handler) // 0
 1b0:	4a01      	ldr	r2, [pc, #4]	; (1b8 <WWDG_handler+0x8>)
 1b2:	4b02      	ldr	r3, [pc, #8]	; (1bc <WWDG_handler+0xc>)
 1b4:	601a      	str	r2, [r3, #0]
 1b6:	bf00      	nop
 1b8:	05fa0004 	.word	0x05fa0004
 1bc:	e000ed0c 	.word	0xe000ed0c

000001c0 <PVD_handler>:
_default_handler(PVD_handler) // 1
 1c0:	4a01      	ldr	r2, [pc, #4]	; (1c8 <PVD_handler+0x8>)
 1c2:	4b02      	ldr	r3, [pc, #8]	; (1cc <PVD_handler+0xc>)
 1c4:	601a      	str	r2, [r3, #0]
 1c6:	bf00      	nop
 1c8:	05fa0004 	.word	0x05fa0004
 1cc:	e000ed0c 	.word	0xe000ed0c

000001d0 <RTC_handler>:
_default_handler(RTC_handler) // 2
 1d0:	4a01      	ldr	r2, [pc, #4]	; (1d8 <RTC_handler+0x8>)
 1d2:	4b02      	ldr	r3, [pc, #8]	; (1dc <RTC_handler+0xc>)
 1d4:	601a      	str	r2, [r3, #0]
 1d6:	bf00      	nop
 1d8:	05fa0004 	.word	0x05fa0004
 1dc:	e000ed0c 	.word	0xe000ed0c

000001e0 <TAMPER_handler>:
_default_handler(TAMPER_handler) // 3
 1e0:	4a01      	ldr	r2, [pc, #4]	; (1e8 <TAMPER_handler+0x8>)
 1e2:	4b02      	ldr	r3, [pc, #8]	; (1ec <TAMPER_handler+0xc>)
 1e4:	601a      	str	r2, [r3, #0]
 1e6:	bf00      	nop
 1e8:	05fa0004 	.word	0x05fa0004
 1ec:	e000ed0c 	.word	0xe000ed0c

000001f0 <FLASH_handler>:
_default_handler(FLASH_handler) // 4
 1f0:	4a01      	ldr	r2, [pc, #4]	; (1f8 <FLASH_handler+0x8>)
 1f2:	4b02      	ldr	r3, [pc, #8]	; (1fc <FLASH_handler+0xc>)
 1f4:	601a      	str	r2, [r3, #0]
 1f6:	bf00      	nop
 1f8:	05fa0004 	.word	0x05fa0004
 1fc:	e000ed0c 	.word	0xe000ed0c

00000200 <RCC_handler>:
_default_handler(RCC_handler) // 5
 200:	4a01      	ldr	r2, [pc, #4]	; (208 <RCC_handler+0x8>)
 202:	4b02      	ldr	r3, [pc, #8]	; (20c <RCC_handler+0xc>)
 204:	601a      	str	r2, [r3, #0]
 206:	bf00      	nop
 208:	05fa0004 	.word	0x05fa0004
 20c:	e000ed0c 	.word	0xe000ed0c

00000210 <EXTI0_handler>:
_default_handler(EXTI0_handler) // 6
 210:	4a01      	ldr	r2, [pc, #4]	; (218 <EXTI0_handler+0x8>)
 212:	4b02      	ldr	r3, [pc, #8]	; (21c <EXTI0_handler+0xc>)
 214:	601a      	str	r2, [r3, #0]
 216:	bf00      	nop
 218:	05fa0004 	.word	0x05fa0004
 21c:	e000ed0c 	.word	0xe000ed0c

00000220 <EXTI1_handler>:
_default_handler(EXTI1_handler) // 7
 220:	4a01      	ldr	r2, [pc, #4]	; (228 <EXTI1_handler+0x8>)
 222:	4b02      	ldr	r3, [pc, #8]	; (22c <EXTI1_handler+0xc>)
 224:	601a      	str	r2, [r3, #0]
 226:	bf00      	nop
 228:	05fa0004 	.word	0x05fa0004
 22c:	e000ed0c 	.word	0xe000ed0c

00000230 <EXTI2_handler>:
_default_handler(EXTI2_handler) // 8
 230:	4a01      	ldr	r2, [pc, #4]	; (238 <EXTI2_handler+0x8>)
 232:	4b02      	ldr	r3, [pc, #8]	; (23c <EXTI2_handler+0xc>)
 234:	601a      	str	r2, [r3, #0]
 236:	bf00      	nop
 238:	05fa0004 	.word	0x05fa0004
 23c:	e000ed0c 	.word	0xe000ed0c

00000240 <EXTI3_handler>:
_default_handler(EXTI3_handler) // 9
 240:	4a01      	ldr	r2, [pc, #4]	; (248 <EXTI3_handler+0x8>)
 242:	4b02      	ldr	r3, [pc, #8]	; (24c <EXTI3_handler+0xc>)
 244:	601a      	str	r2, [r3, #0]
 246:	bf00      	nop
 248:	05fa0004 	.word	0x05fa0004
 24c:	e000ed0c 	.word	0xe000ed0c

00000250 <EXTI4_handler>:
_default_handler(EXTI4_handler) // 10
 250:	4a01      	ldr	r2, [pc, #4]	; (258 <EXTI4_handler+0x8>)
 252:	4b02      	ldr	r3, [pc, #8]	; (25c <EXTI4_handler+0xc>)
 254:	601a      	str	r2, [r3, #0]
 256:	bf00      	nop
 258:	05fa0004 	.word	0x05fa0004
 25c:	e000ed0c 	.word	0xe000ed0c

00000260 <DMA1CH1_handler>:
_default_handler(DMA1CH1_handler) // 11
 260:	4a01      	ldr	r2, [pc, #4]	; (268 <DMA1CH1_handler+0x8>)
 262:	4b02      	ldr	r3, [pc, #8]	; (26c <DMA1CH1_handler+0xc>)
 264:	601a      	str	r2, [r3, #0]
 266:	bf00      	nop
 268:	05fa0004 	.word	0x05fa0004
 26c:	e000ed0c 	.word	0xe000ed0c

00000270 <DMA1CH2_handler>:
_default_handler(DMA1CH2_handler) // 12
 270:	4a01      	ldr	r2, [pc, #4]	; (278 <DMA1CH2_handler+0x8>)
 272:	4b02      	ldr	r3, [pc, #8]	; (27c <DMA1CH2_handler+0xc>)
 274:	601a      	str	r2, [r3, #0]
 276:	bf00      	nop
 278:	05fa0004 	.word	0x05fa0004
 27c:	e000ed0c 	.word	0xe000ed0c

00000280 <reset_mcu>:

void __attribute__((naked)) reset_mcu(){
// réinitialise le µC
	_reset_mcu();
 280:	4a01      	ldr	r2, [pc, #4]	; (288 <reset_mcu+0x8>)
 282:	4b02      	ldr	r3, [pc, #8]	; (28c <reset_mcu+0xc>)
 284:	601a      	str	r2, [r3, #0]
 286:	bf00      	nop
 288:	05fa0004 	.word	0x05fa0004
 28c:	e000ed0c 	.word	0xe000ed0c

00000290 <startup>:
    (unsigned int *)  reset_mcu, // 59 DMA2CH4_5
};


void startup()
{
 290:	b508      	push	{r3, lr}
    /* Set memory in bss segment to zeros */
    unsigned int * bss_start_p = &_BSS_START; 
    unsigned int * bss_end_p = &_BSS_END;

    while(bss_start_p != bss_end_p)
 292:	4b19      	ldr	r3, [pc, #100]	; (2f8 <startup+0x68>)
 294:	4a19      	ldr	r2, [pc, #100]	; (2fc <startup+0x6c>)
 296:	429a      	cmp	r2, r3
 298:	d00b      	beq.n	2b2 <startup+0x22>
 29a:	1d13      	adds	r3, r2, #4
 29c:	4a16      	ldr	r2, [pc, #88]	; (2f8 <startup+0x68>)
 29e:	1ad2      	subs	r2, r2, r3
 2a0:	f022 0203 	bic.w	r2, r2, #3
 2a4:	441a      	add	r2, r3
 2a6:	3b04      	subs	r3, #4
    {
        *bss_start_p = 0;
 2a8:	2100      	movs	r1, #0
 2aa:	f843 1b04 	str.w	r1, [r3], #4
{
    /* Set memory in bss segment to zeros */
    unsigned int * bss_start_p = &_BSS_START; 
    unsigned int * bss_end_p = &_BSS_END;

    while(bss_start_p != bss_end_p)
 2ae:	4293      	cmp	r3, r2
 2b0:	d1fb      	bne.n	2aa <startup+0x1a>
     * read/write memory */
    unsigned int * data_rom_start_p = &_DATA_ROM_START;
    unsigned int * data_ram_start_p = &_DATA_RAM_START;
    unsigned int * data_ram_end_p = &_DATA_RAM_END;

    while(data_ram_start_p != data_ram_end_p)
 2b2:	4b13      	ldr	r3, [pc, #76]	; (300 <startup+0x70>)
 2b4:	4a13      	ldr	r2, [pc, #76]	; (304 <startup+0x74>)
 2b6:	429a      	cmp	r2, r3
 2b8:	d00d      	beq.n	2d6 <startup+0x46>
 2ba:	4a13      	ldr	r2, [pc, #76]	; (308 <startup+0x78>)
 2bc:	4b13      	ldr	r3, [pc, #76]	; (30c <startup+0x7c>)
 2be:	4810      	ldr	r0, [pc, #64]	; (300 <startup+0x70>)
 2c0:	1ac0      	subs	r0, r0, r3
 2c2:	f020 0003 	bic.w	r0, r0, #3
 2c6:	4418      	add	r0, r3
 2c8:	3b04      	subs	r3, #4
    {
        *data_ram_start_p = *data_rom_start_p;
 2ca:	f852 1b04 	ldr.w	r1, [r2], #4
 2ce:	f843 1b04 	str.w	r1, [r3], #4
     * read/write memory */
    unsigned int * data_rom_start_p = &_DATA_ROM_START;
    unsigned int * data_ram_start_p = &_DATA_RAM_START;
    unsigned int * data_ram_end_p = &_DATA_RAM_END;

    while(data_ram_start_p != data_ram_end_p)
 2d2:	4283      	cmp	r3, r0
 2d4:	d1f9      	bne.n	2ca <startup+0x3a>
        *data_ram_start_p = *data_rom_start_p;
        data_ram_start_p++;
        data_rom_start_p++;
    }
    // active les interruptions et les fault handler
    __enable_irq();
 2d6:	b662      	cpsie	i
    __enable_fault_irq();
 2d8:	b661      	cpsie	f
    // initialisaton de la pile PSP et commutation 
    // vers cette pile.
    asm volatile(
 2da:	4b0d      	ldr	r3, [pc, #52]	; (310 <startup+0x80>)
 2dc:	4618      	mov	r0, r3
 2de:	f380 8809 	msr	PSP, r0
 2e2:	f3ef 8014 	mrs	r0, CONTROL
 2e6:	f040 0002 	orr.w	r0, r0, #2
 2ea:	f380 8814 	msr	CONTROL, r0
 2ee:	f3bf 8f6f 	isb	sy
    "msr CONTROL,r0\n"
    "ISB\n"
    :: [psp_top] "r" (PSP_TOP)
    );
    /* Now we are ready to start the main function */
    main();
 2f2:	f000 f85f 	bl	3b4 <main>
 2f6:	bd08      	pop	{r3, pc}
 2f8:	20000008 	.word	0x20000008
 2fc:	20000000 	.word	0x20000000
 300:	20000000 	.word	0x20000000
 304:	20000000 	.word	0x20000000
 308:	000004dc 	.word	0x000004dc
 30c:	20000004 	.word	0x20000004
 310:	20004c00 	.word	0x20004c00

00000314 <SVC_handler>:
#define SVC_TIMER (3) // démarre la minuterie
#define SVC_PRIVILIGED (4) // active l'exécution prévilégiée
#define SVC_RESET (5) // réinialise le MCU


void __attribute__((__interrupt__)) SVC_handler(){
 314:	4668      	mov	r0, sp
 316:	f020 0107 	bic.w	r1, r0, #7
 31a:	468d      	mov	sp, r1
 31c:	b401      	push	{r0}
	unsigned svc_id, argc;
	void **argv; 
	asm volatile (
 31e:	f3ef 8009 	mrs	r0, PSP
 322:	6981      	ldr	r1, [r0, #24]
 324:	f1a1 0102 	sub.w	r1, r1, #2
 328:	780b      	ldrb	r3, [r1, #0]
 32a:	6802      	ldr	r2, [r0, #0]
 32c:	6841      	ldr	r1, [r0, #4]
    "ldrb %[svc_id], [r1]\n" // charge l'octet faible i.e. no de service
    "ldr %[argc],[r0]\n"
    "ldr %[argv],[r0,#4]\n"
    : [svc_id] "=r" (svc_id), [argc] "=r" (argc), [argv] "=r" (argv) 
    );
	switch (svc_id){
 32e:	3b01      	subs	r3, #1
 330:	2b04      	cmp	r3, #4
 332:	d81b      	bhi.n	36c <SVC_handler+0x58>
 334:	e8df f003 	tbb	[pc, r3]
 338:	100d0803 	.word	0x100d0803
 33c:	17          	.byte	0x17
 33d:	00          	.byte	0x00
	case SVC_LED_ON: 
		GPIOC_BRR=GRN_LED;
 33e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 342:	4b0c      	ldr	r3, [pc, #48]	; (374 <SVC_handler+0x60>)
 344:	601a      	str	r2, [r3, #0]
		break;
 346:	e011      	b.n	36c <SVC_handler+0x58>
	case SVC_LED_OFF:
		GPIOC_BSRR=GRN_LED;
 348:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 34c:	4b0a      	ldr	r3, [pc, #40]	; (378 <SVC_handler+0x64>)
 34e:	601a      	str	r2, [r3, #0]
		break;
 350:	e00c      	b.n	36c <SVC_handler+0x58>
	case SVC_TIMER: 
		timer=argc;
 352:	4b0a      	ldr	r3, [pc, #40]	; (37c <SVC_handler+0x68>)
 354:	601a      	str	r2, [r3, #0]
		break;
 356:	e009      	b.n	36c <SVC_handler+0x58>
	case SVC_PRIVILIGED:
		asm volatile(
 358:	f3ef 8014 	mrs	r0, CONTROL
 35c:	f020 0000 	bic.w	r0, r0, #0
 360:	f380 8814 	msr	CONTROL, r0
		"mrs r0,CONTROL\n"
		"bic r0,#0\n"       // bit 0 sélectionne le niveau de privilège
		"msr CONTROL, r0\n"
		);
		break;
 364:	e002      	b.n	36c <SVC_handler+0x58>
    case SVC_RESET:
	    _reset_mcu();
 366:	4a06      	ldr	r2, [pc, #24]	; (380 <SVC_handler+0x6c>)
 368:	4b06      	ldr	r3, [pc, #24]	; (384 <SVC_handler+0x70>)
 36a:	601a      	str	r2, [r3, #0]
	    break;
	}	
}
 36c:	f85d 0b04 	ldr.w	r0, [sp], #4
 370:	4685      	mov	sp, r0
 372:	4770      	bx	lr
 374:	40011014 	.word	0x40011014
 378:	40011010 	.word	0x40011010
 37c:	20000000 	.word	0x20000000
 380:	05fa0004 	.word	0x05fa0004
 384:	e000ed0c 	.word	0xe000ed0c

00000388 <STK_handler>:

// interruption coretimer
void __attribute__((__interrupt__)) STK_handler(){
 388:	4668      	mov	r0, sp
 38a:	f020 0107 	bic.w	r1, r0, #7
 38e:	468d      	mov	sp, r1
 390:	b401      	push	{r0}
	ticks++;
 392:	4b07      	ldr	r3, [pc, #28]	; (3b0 <STK_handler+0x28>)
 394:	685a      	ldr	r2, [r3, #4]
 396:	3201      	adds	r2, #1
 398:	605a      	str	r2, [r3, #4]
	if (timer) {timer--;}
 39a:	681b      	ldr	r3, [r3, #0]
 39c:	b11b      	cbz	r3, 3a6 <STK_handler+0x1e>
 39e:	4a04      	ldr	r2, [pc, #16]	; (3b0 <STK_handler+0x28>)
 3a0:	6813      	ldr	r3, [r2, #0]
 3a2:	3b01      	subs	r3, #1
 3a4:	6013      	str	r3, [r2, #0]
}
 3a6:	f85d 0b04 	ldr.w	r0, [sp], #4
 3aa:	4685      	mov	sp, r0
 3ac:	4770      	bx	lr
 3ae:	bf00      	nop
 3b0:	20000000 	.word	0x20000000

000003b4 <main>:

// configure SYSCLK à la fréquence maximale de 72 Mhz
// en utilisant le cristal externe (HSE) et le PLL
static void set_sysclock(){
	 // active l'oscillateur externe
	RCC_CR|=1<<RCC_CR_HSEON;
 3b4:	4a2a      	ldr	r2, [pc, #168]	; (460 <main+0xac>)
 3b6:	6813      	ldr	r3, [r2, #0]
 3b8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 3bc:	6013      	str	r3, [r2, #0]
	 // attend que l'oscillateur soit prêt
   while (! (RCC_CR & (1<<RCC_CR_HSERDY)));
 3be:	4613      	mov	r3, r2
 3c0:	681a      	ldr	r2, [r3, #0]
 3c2:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 3c6:	d0fb      	beq.n	3c0 <main+0xc>
     // sélection PREDIV1 pour la source du PLL
     // multiplie la fréquence HSE par 9 
     // pour une fréquence maximale Fsysclk de 72 Mhz
    RCC_CFGR|=(PLLSRC_PREDIV1<<RCC_CFGR_PLLSRC)|(PLLMUL9<<RCC_CFGR_PLLMUL);
 3c8:	4a26      	ldr	r2, [pc, #152]	; (464 <main+0xb0>)
 3ca:	6813      	ldr	r3, [r2, #0]
 3cc:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 3d0:	6013      	str	r3, [r2, #0]
    // active le PLL
    RCC_CR|=1<<RCC_CR_PLLON;
 3d2:	3a04      	subs	r2, #4
 3d4:	6813      	ldr	r3, [r2, #0]
 3d6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 3da:	6013      	str	r3, [r2, #0]
    // Attend que le PLL soit prêt
    while (! (RCC_CR & (1<<RCC_CR_PLLRDY)));
 3dc:	4613      	mov	r3, r2
 3de:	681a      	ldr	r2, [r3, #0]
 3e0:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 3e4:	d0fb      	beq.n	3de <main+0x2a>
    // ajoute délais d'accès à la mémoire flash
    FLASH_ACR|=WAIT_2_CY;
 3e6:	4a20      	ldr	r2, [pc, #128]	; (468 <main+0xb4>)
 3e8:	6813      	ldr	r3, [r2, #0]
 3ea:	f043 0302 	orr.w	r3, r3, #2
 3ee:	6013      	str	r3, [r2, #0]
    // SélectionNE le PLL comme source pour SYSCLK
    RCC_CFGR|=PLL_CLK<<RCC_CFGR_SW;
 3f0:	4b1c      	ldr	r3, [pc, #112]	; (464 <main+0xb0>)
 3f2:	681a      	ldr	r2, [r3, #0]
 3f4:	f042 0202 	orr.w	r2, r2, #2
 3f8:	601a      	str	r2, [r3, #0]
	// La fréquence maximale pour APB1 doit-être de 36 Mhz
	// donc divise SYSCLK/2
	RCC_CFGR|=PPRECLK_DIV2;
 3fa:	681a      	ldr	r2, [r3, #0]
 3fc:	f042 0204 	orr.w	r2, r2, #4
 400:	601a      	str	r2, [r3, #0]
// configure SYSTICKS pour un cycle 1 msec
// source AHB/8
// valeur reload 72Mhz/8/1000=9000
#define MSEC_DLY 9000
static void config_systicks(){
	STK_LOAD=MSEC_DLY-1;
 402:	f242 3227 	movw	r2, #8999	; 0x2327
 406:	4b19      	ldr	r3, [pc, #100]	; (46c <main+0xb8>)
 408:	601a      	str	r2, [r3, #0]
	STK_CTRL=(1<<STK_TICKINT)|(1<<STK_ENABLE);
 40a:	2203      	movs	r2, #3
 40c:	3b04      	subs	r3, #4
 40e:	601a      	str	r2, [r3, #0]
#define _mask_cnf(cnf,bit) (cnf & ~(CNF_MASK<<((bit&7)*4)))
#define _apply_cnf(cnf,bit,pin_cnf) (_mask_cnf(cnf,bit) | pin_cnf<<((bit&7)*4)) 
// PC13 mode{0:1}=10, CNF{2:3}=01 -> 6
#define PC13_CNF 6
static void port_c_setup(){
	RCC_APB2ENR|=1<<GPIOC_EN;
 410:	4a17      	ldr	r2, [pc, #92]	; (470 <main+0xbc>)
 412:	6813      	ldr	r3, [r2, #0]
 414:	f043 0310 	orr.w	r3, r3, #16
 418:	6013      	str	r3, [r2, #0]
	GPIOC_CRH=_apply_cnf(DEFAULT_PORT_CNF,LED_PIN,PC13_CNF);
 41a:	4a16      	ldr	r2, [pc, #88]	; (474 <main+0xc0>)
 41c:	4b16      	ldr	r3, [pc, #88]	; (478 <main+0xc4>)
 41e:	601a      	str	r2, [r3, #0]
void main(void){
	void **argv=NULL;
	set_sysclock();
	config_systicks();
	port_c_setup();
	_unprivileged(); // à partir d'ici exécution sans privilèges.
 420:	f3ef 8014 	mrs	r0, CONTROL
 424:	f040 0001 	orr.w	r0, r0, #1
 428:	f380 8814 	msr	CONTROL, r0
 42c:	f3bf 8f6f 	isb	sy
	while (1){
		_svc_call(SVC_LED_OFF,0,argv);
 430:	2100      	movs	r1, #0
		_svc_call(SVC_TIMER,RATE,argv);
		_wait_timeout();
 432:	4a12      	ldr	r2, [pc, #72]	; (47c <main+0xc8>)
	set_sysclock();
	config_systicks();
	port_c_setup();
	_unprivileged(); // à partir d'ici exécution sans privilèges.
	while (1){
		_svc_call(SVC_LED_OFF,0,argv);
 434:	2000      	movs	r0, #0
 436:	4609      	mov	r1, r1
 438:	df02      	svc	2
		_svc_call(SVC_TIMER,RATE,argv);
 43a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 43e:	4609      	mov	r1, r1
 440:	df03      	svc	3
		_wait_timeout();
 442:	6813      	ldr	r3, [r2, #0]
 444:	2b00      	cmp	r3, #0
 446:	d1fc      	bne.n	442 <main+0x8e>
		_svc_call(SVC_LED_ON,0,argv);
 448:	2000      	movs	r0, #0
 44a:	4609      	mov	r1, r1
 44c:	df01      	svc	1
		_svc_call(SVC_TIMER,RATE,argv);
 44e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 452:	4609      	mov	r1, r1
 454:	df03      	svc	3
		_wait_timeout();
 456:	6813      	ldr	r3, [r2, #0]
 458:	2b00      	cmp	r3, #0
 45a:	d1fc      	bne.n	456 <main+0xa2>
 45c:	e7ea      	b.n	434 <main+0x80>
 45e:	bf00      	nop
 460:	40021000 	.word	0x40021000
 464:	40021004 	.word	0x40021004
 468:	40022000 	.word	0x40022000
 46c:	e000e014 	.word	0xe000e014
 470:	40021018 	.word	0x40021018
 474:	44644444 	.word	0x44644444
 478:	40011004 	.word	0x40011004
 47c:	20000000 	.word	0x20000000

00000480 <enable_interrupt>:


typedef volatile uint32_t* t_iser;
void enable_interrupt(unsigned irq){
	t_iser iser=(t_iser)(NVIC_ISER0_ADR);
	if (irq>LAST_IRQ) return ;
 480:	283b      	cmp	r0, #59	; 0x3b
 482:	d80c      	bhi.n	49e <enable_interrupt+0x1e>
	iser[irq/32]|=1<<(irq%32);
 484:	0943      	lsrs	r3, r0, #5
 486:	009b      	lsls	r3, r3, #2
 488:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 48c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 490:	6819      	ldr	r1, [r3, #0]
 492:	f000 001f 	and.w	r0, r0, #31
 496:	2201      	movs	r2, #1
 498:	4082      	lsls	r2, r0
 49a:	430a      	orrs	r2, r1
 49c:	601a      	str	r2, [r3, #0]
 49e:	4770      	bx	lr

000004a0 <disable_interrupt>:
}

typedef volatile uint32_t* t_icer;
void disable_interrupt(unsigned irq){
	t_icer icer=(t_icer)(NVIC_ICER0_ADR);
	if (irq>LAST_IRQ) return ;
 4a0:	283b      	cmp	r0, #59	; 0x3b
 4a2:	d80e      	bhi.n	4c2 <disable_interrupt+0x22>
	iser[irq/32]|=1<<(irq%32);
	
}

typedef volatile uint32_t* t_icer;
void disable_interrupt(unsigned irq){
 4a4:	b410      	push	{r4}
	t_icer icer=(t_icer)(NVIC_ICER0_ADR);
	if (irq>LAST_IRQ) return ;
	icer[irq/32]&=~(1<<(irq%32));
 4a6:	0944      	lsrs	r4, r0, #5
 4a8:	4906      	ldr	r1, [pc, #24]	; (4c4 <disable_interrupt+0x24>)
 4aa:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
 4ae:	f000 001f 	and.w	r0, r0, #31
 4b2:	2301      	movs	r3, #1
 4b4:	4083      	lsls	r3, r0
 4b6:	ea22 0303 	bic.w	r3, r2, r3
 4ba:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
	
}
 4be:	f85d 4b04 	ldr.w	r4, [sp], #4
 4c2:	4770      	bx	lr
 4c4:	e000e180 	.word	0xe000e180

000004c8 <set_int_priority>:

typedef uint8_t* t_ipr;

void set_int_priority(unsigned irq, unsigned priority){
	t_ipr ipr=(t_ipr)NVIC_IPR0_ADR;
	if (irq>LAST_IRQ) return;
 4c8:	283b      	cmp	r0, #59	; 0x3b
 4ca:	d805      	bhi.n	4d8 <set_int_priority+0x10>
	ipr[irq]=(priority&15)<<4;
 4cc:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 4d0:	f500 4064 	add.w	r0, r0, #58368	; 0xe400
 4d4:	0109      	lsls	r1, r1, #4
 4d6:	7001      	strb	r1, [r0, #0]
 4d8:	4770      	bx	lr
 4da:	bf00      	nop

Imprime le code assembleur de svc_demo.o avec objdump
arm-none-eabi-objdump -S --disassemble svc_demo.o

svc_demo.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <SVC_handler>:
#define SVC_TIMER (3) // démarre la minuterie
#define SVC_PRIVILIGED (4) // active l'exécution prévilégiée
#define SVC_RESET (5) // réinialise le MCU


void __attribute__((__interrupt__)) SVC_handler(){
   0:	4668      	mov	r0, sp
   2:	f020 0107 	bic.w	r1, r0, #7
   6:	468d      	mov	sp, r1
   8:	b401      	push	{r0}
	unsigned svc_id, argc;
	void **argv; 
	asm volatile (
   a:	f3ef 8009 	mrs	r0, PSP
   e:	6981      	ldr	r1, [r0, #24]
  10:	f1a1 0102 	sub.w	r1, r1, #2
  14:	780b      	ldrb	r3, [r1, #0]
  16:	6802      	ldr	r2, [r0, #0]
  18:	6841      	ldr	r1, [r0, #4]
    "ldrb %[svc_id], [r1]\n" // charge l'octet faible i.e. no de service
    "ldr %[argc],[r0]\n"
    "ldr %[argv],[r0,#4]\n"
    : [svc_id] "=r" (svc_id), [argc] "=r" (argc), [argv] "=r" (argv) 
    );
	switch (svc_id){
  1a:	3b01      	subs	r3, #1
  1c:	2b04      	cmp	r3, #4
  1e:	d81b      	bhi.n	58 <SVC_handler+0x58>
  20:	e8df f003 	tbb	[pc, r3]
  24:	100d0803 	.word	0x100d0803
  28:	17          	.byte	0x17
  29:	00          	.byte	0x00
	case SVC_LED_ON: 
		GPIOC_BRR=GRN_LED;
  2a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  2e:	4b0c      	ldr	r3, [pc, #48]	; (60 <SVC_handler+0x60>)
  30:	601a      	str	r2, [r3, #0]
		break;
  32:	e011      	b.n	58 <SVC_handler+0x58>
	case SVC_LED_OFF:
		GPIOC_BSRR=GRN_LED;
  34:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  38:	4b0a      	ldr	r3, [pc, #40]	; (64 <SVC_handler+0x64>)
  3a:	601a      	str	r2, [r3, #0]
		break;
  3c:	e00c      	b.n	58 <SVC_handler+0x58>
	case SVC_TIMER: 
		timer=argc;
  3e:	4b0a      	ldr	r3, [pc, #40]	; (68 <SVC_handler+0x68>)
  40:	601a      	str	r2, [r3, #0]
		break;
  42:	e009      	b.n	58 <SVC_handler+0x58>
	case SVC_PRIVILIGED:
		asm volatile(
  44:	f3ef 8014 	mrs	r0, CONTROL
  48:	f020 0000 	bic.w	r0, r0, #0
  4c:	f380 8814 	msr	CONTROL, r0
		"mrs r0,CONTROL\n"
		"bic r0,#0\n"       // bit 0 sélectionne le niveau de privilège
		"msr CONTROL, r0\n"
		);
		break;
  50:	e002      	b.n	58 <SVC_handler+0x58>
    case SVC_RESET:
	    _reset_mcu();
  52:	4a06      	ldr	r2, [pc, #24]	; (6c <SVC_handler+0x6c>)
  54:	4b06      	ldr	r3, [pc, #24]	; (70 <SVC_handler+0x70>)
  56:	601a      	str	r2, [r3, #0]
	    break;
	}	
}
  58:	f85d 0b04 	ldr.w	r0, [sp], #4
  5c:	4685      	mov	sp, r0
  5e:	4770      	bx	lr
  60:	40011014 	.word	0x40011014
  64:	40011010 	.word	0x40011010
  68:	00000000 	.word	0x00000000
  6c:	05fa0004 	.word	0x05fa0004
  70:	e000ed0c 	.word	0xe000ed0c

00000074 <STK_handler>:

// interruption coretimer
void __attribute__((__interrupt__)) STK_handler(){
  74:	4668      	mov	r0, sp
  76:	f020 0107 	bic.w	r1, r0, #7
  7a:	468d      	mov	sp, r1
  7c:	b401      	push	{r0}
	ticks++;
  7e:	4b07      	ldr	r3, [pc, #28]	; (9c <STK_handler+0x28>)
  80:	685a      	ldr	r2, [r3, #4]
  82:	3201      	adds	r2, #1
  84:	605a      	str	r2, [r3, #4]
	if (timer) {timer--;}
  86:	681b      	ldr	r3, [r3, #0]
  88:	b11b      	cbz	r3, 92 <STK_handler+0x1e>
  8a:	4a04      	ldr	r2, [pc, #16]	; (9c <STK_handler+0x28>)
  8c:	6813      	ldr	r3, [r2, #0]
  8e:	3b01      	subs	r3, #1
  90:	6013      	str	r3, [r2, #0]
}
  92:	f85d 0b04 	ldr.w	r0, [sp], #4
  96:	4685      	mov	sp, r0
  98:	4770      	bx	lr
  9a:	bf00      	nop
  9c:	00000000 	.word	0x00000000

000000a0 <main>:

// configure SYSCLK à la fréquence maximale de 72 Mhz
// en utilisant le cristal externe (HSE) et le PLL
static void set_sysclock(){
	 // active l'oscillateur externe
	RCC_CR|=1<<RCC_CR_HSEON;
  a0:	4a2a      	ldr	r2, [pc, #168]	; (14c <main+0xac>)
  a2:	6813      	ldr	r3, [r2, #0]
  a4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  a8:	6013      	str	r3, [r2, #0]
	 // attend que l'oscillateur soit prêt
   while (! (RCC_CR & (1<<RCC_CR_HSERDY)));
  aa:	4613      	mov	r3, r2
  ac:	681a      	ldr	r2, [r3, #0]
  ae:	f412 3f00 	tst.w	r2, #131072	; 0x20000
  b2:	d0fb      	beq.n	ac <main+0xc>
     // sélection PREDIV1 pour la source du PLL
     // multiplie la fréquence HSE par 9 
     // pour une fréquence maximale Fsysclk de 72 Mhz
    RCC_CFGR|=(PLLSRC_PREDIV1<<RCC_CFGR_PLLSRC)|(PLLMUL9<<RCC_CFGR_PLLMUL);
  b4:	4a26      	ldr	r2, [pc, #152]	; (150 <main+0xb0>)
  b6:	6813      	ldr	r3, [r2, #0]
  b8:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
  bc:	6013      	str	r3, [r2, #0]
    // active le PLL
    RCC_CR|=1<<RCC_CR_PLLON;
  be:	3a04      	subs	r2, #4
  c0:	6813      	ldr	r3, [r2, #0]
  c2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  c6:	6013      	str	r3, [r2, #0]
    // Attend que le PLL soit prêt
    while (! (RCC_CR & (1<<RCC_CR_PLLRDY)));
  c8:	4613      	mov	r3, r2
  ca:	681a      	ldr	r2, [r3, #0]
  cc:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
  d0:	d0fb      	beq.n	ca <main+0x2a>
    // ajoute délais d'accès à la mémoire flash
    FLASH_ACR|=WAIT_2_CY;
  d2:	4a20      	ldr	r2, [pc, #128]	; (154 <main+0xb4>)
  d4:	6813      	ldr	r3, [r2, #0]
  d6:	f043 0302 	orr.w	r3, r3, #2
  da:	6013      	str	r3, [r2, #0]
    // SélectionNE le PLL comme source pour SYSCLK
    RCC_CFGR|=PLL_CLK<<RCC_CFGR_SW;
  dc:	4b1c      	ldr	r3, [pc, #112]	; (150 <main+0xb0>)
  de:	681a      	ldr	r2, [r3, #0]
  e0:	f042 0202 	orr.w	r2, r2, #2
  e4:	601a      	str	r2, [r3, #0]
	// La fréquence maximale pour APB1 doit-être de 36 Mhz
	// donc divise SYSCLK/2
	RCC_CFGR|=PPRECLK_DIV2;
  e6:	681a      	ldr	r2, [r3, #0]
  e8:	f042 0204 	orr.w	r2, r2, #4
  ec:	601a      	str	r2, [r3, #0]
// configure SYSTICKS pour un cycle 1 msec
// source AHB/8
// valeur reload 72Mhz/8/1000=9000
#define MSEC_DLY 9000
static void config_systicks(){
	STK_LOAD=MSEC_DLY-1;
  ee:	f242 3227 	movw	r2, #8999	; 0x2327
  f2:	4b19      	ldr	r3, [pc, #100]	; (158 <main+0xb8>)
  f4:	601a      	str	r2, [r3, #0]
	STK_CTRL=(1<<STK_TICKINT)|(1<<STK_ENABLE);
  f6:	2203      	movs	r2, #3
  f8:	3b04      	subs	r3, #4
  fa:	601a      	str	r2, [r3, #0]
#define _mask_cnf(cnf,bit) (cnf & ~(CNF_MASK<<((bit&7)*4)))
#define _apply_cnf(cnf,bit,pin_cnf) (_mask_cnf(cnf,bit) | pin_cnf<<((bit&7)*4)) 
// PC13 mode{0:1}=10, CNF{2:3}=01 -> 6
#define PC13_CNF 6
static void port_c_setup(){
	RCC_APB2ENR|=1<<GPIOC_EN;
  fc:	4a17      	ldr	r2, [pc, #92]	; (15c <main+0xbc>)
  fe:	6813      	ldr	r3, [r2, #0]
 100:	f043 0310 	orr.w	r3, r3, #16
 104:	6013      	str	r3, [r2, #0]
	GPIOC_CRH=_apply_cnf(DEFAULT_PORT_CNF,LED_PIN,PC13_CNF);
 106:	4a16      	ldr	r2, [pc, #88]	; (160 <main+0xc0>)
 108:	4b16      	ldr	r3, [pc, #88]	; (164 <main+0xc4>)
 10a:	601a      	str	r2, [r3, #0]
void main(void){
	void **argv=NULL;
	set_sysclock();
	config_systicks();
	port_c_setup();
	_unprivileged(); // à partir d'ici exécution sans privilèges.
 10c:	f3ef 8014 	mrs	r0, CONTROL
 110:	f040 0001 	orr.w	r0, r0, #1
 114:	f380 8814 	msr	CONTROL, r0
 118:	f3bf 8f6f 	isb	sy
	while (1){
		_svc_call(SVC_LED_OFF,0,argv);
 11c:	2100      	movs	r1, #0
		_svc_call(SVC_TIMER,RATE,argv);
		_wait_timeout();
 11e:	4a12      	ldr	r2, [pc, #72]	; (168 <main+0xc8>)
	set_sysclock();
	config_systicks();
	port_c_setup();
	_unprivileged(); // à partir d'ici exécution sans privilèges.
	while (1){
		_svc_call(SVC_LED_OFF,0,argv);
 120:	2000      	movs	r0, #0
 122:	4609      	mov	r1, r1
 124:	df02      	svc	2
		_svc_call(SVC_TIMER,RATE,argv);
 126:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 12a:	4609      	mov	r1, r1
 12c:	df03      	svc	3
		_wait_timeout();
 12e:	6813      	ldr	r3, [r2, #0]
 130:	2b00      	cmp	r3, #0
 132:	d1fc      	bne.n	12e <main+0x8e>
		_svc_call(SVC_LED_ON,0,argv);
 134:	2000      	movs	r0, #0
 136:	4609      	mov	r1, r1
 138:	df01      	svc	1
		_svc_call(SVC_TIMER,RATE,argv);
 13a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 13e:	4609      	mov	r1, r1
 140:	df03      	svc	3
		_wait_timeout();
 142:	6813      	ldr	r3, [r2, #0]
 144:	2b00      	cmp	r3, #0
 146:	d1fc      	bne.n	142 <main+0xa2>
 148:	e7ea      	b.n	120 <main+0x80>
 14a:	bf00      	nop
 14c:	40021000 	.word	0x40021000
 150:	40021004 	.word	0x40021004
 154:	40022000 	.word	0x40022000
 158:	e000e014 	.word	0xe000e014
 15c:	40021018 	.word	0x40021018
 160:	44644444 	.word	0x44644444
 164:	40011004 	.word	0x40011004
 168:	00000000 	.word	0x00000000

Imprime le code assembleur de startup.o avec objdump
arm-none-eabi-objdump -S --disassemble startup.o

startup.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <NMI_handler>:
// réinitialise le µC
// L'attribut (weak) permet de les remplacer par une fonction du même nom
// sans avoir à modifier le fichier startup.c

// core exceptions
_default_handler(NMI_handler) // 2
   0:	4a01      	ldr	r2, [pc, #4]	; (8 <NMI_handler+0x8>)
   2:	4b02      	ldr	r3, [pc, #8]	; (c <NMI_handler+0xc>)
   4:	601a      	str	r2, [r3, #0]
   6:	bf00      	nop
   8:	05fa0004 	.word	0x05fa0004
   c:	e000ed0c 	.word	0xe000ed0c

00000010 <HARD_FAULT_handler>:
_default_handler(HARD_FAULT_handler) // 3
  10:	4a01      	ldr	r2, [pc, #4]	; (18 <HARD_FAULT_handler+0x8>)
  12:	4b02      	ldr	r3, [pc, #8]	; (1c <HARD_FAULT_handler+0xc>)
  14:	601a      	str	r2, [r3, #0]
  16:	bf00      	nop
  18:	05fa0004 	.word	0x05fa0004
  1c:	e000ed0c 	.word	0xe000ed0c

00000020 <MM_FAULT_handler>:
_default_handler(MM_FAULT_handler)  // 4
  20:	4a01      	ldr	r2, [pc, #4]	; (28 <MM_FAULT_handler+0x8>)
  22:	4b02      	ldr	r3, [pc, #8]	; (2c <MM_FAULT_handler+0xc>)
  24:	601a      	str	r2, [r3, #0]
  26:	bf00      	nop
  28:	05fa0004 	.word	0x05fa0004
  2c:	e000ed0c 	.word	0xe000ed0c

00000030 <BUS_FAULT_handler>:
_default_handler(BUS_FAULT_handler) // 5
  30:	4a01      	ldr	r2, [pc, #4]	; (38 <BUS_FAULT_handler+0x8>)
  32:	4b02      	ldr	r3, [pc, #8]	; (3c <BUS_FAULT_handler+0xc>)
  34:	601a      	str	r2, [r3, #0]
  36:	bf00      	nop
  38:	05fa0004 	.word	0x05fa0004
  3c:	e000ed0c 	.word	0xe000ed0c

00000040 <USAGE_FAULT_handler>:
_default_handler(USAGE_FAULT_handler) // 6
  40:	4a01      	ldr	r2, [pc, #4]	; (48 <USAGE_FAULT_handler+0x8>)
  42:	4b02      	ldr	r3, [pc, #8]	; (4c <USAGE_FAULT_handler+0xc>)
  44:	601a      	str	r2, [r3, #0]
  46:	bf00      	nop
  48:	05fa0004 	.word	0x05fa0004
  4c:	e000ed0c 	.word	0xe000ed0c

00000050 <SVC_handler>:
_default_handler(SVC_handler) // 11
  50:	4a01      	ldr	r2, [pc, #4]	; (58 <SVC_handler+0x8>)
  52:	4b02      	ldr	r3, [pc, #8]	; (5c <SVC_handler+0xc>)
  54:	601a      	str	r2, [r3, #0]
  56:	bf00      	nop
  58:	05fa0004 	.word	0x05fa0004
  5c:	e000ed0c 	.word	0xe000ed0c

00000060 <PENDSV_handler>:
_default_handler(PENDSV_handler) // 14
  60:	4a01      	ldr	r2, [pc, #4]	; (68 <PENDSV_handler+0x8>)
  62:	4b02      	ldr	r3, [pc, #8]	; (6c <PENDSV_handler+0xc>)
  64:	601a      	str	r2, [r3, #0]
  66:	bf00      	nop
  68:	05fa0004 	.word	0x05fa0004
  6c:	e000ed0c 	.word	0xe000ed0c

00000070 <STK_handler>:
_default_handler(STK_handler) // 15
  70:	4a01      	ldr	r2, [pc, #4]	; (78 <STK_handler+0x8>)
  72:	4b02      	ldr	r3, [pc, #8]	; (7c <STK_handler+0xc>)
  74:	601a      	str	r2, [r3, #0]
  76:	bf00      	nop
  78:	05fa0004 	.word	0x05fa0004
  7c:	e000ed0c 	.word	0xe000ed0c

00000080 <WWDG_handler>:

// IRQ
_default_handler(WWDG_handler) // 0
  80:	4a01      	ldr	r2, [pc, #4]	; (88 <WWDG_handler+0x8>)
  82:	4b02      	ldr	r3, [pc, #8]	; (8c <WWDG_handler+0xc>)
  84:	601a      	str	r2, [r3, #0]
  86:	bf00      	nop
  88:	05fa0004 	.word	0x05fa0004
  8c:	e000ed0c 	.word	0xe000ed0c

00000090 <PVD_handler>:
_default_handler(PVD_handler) // 1
  90:	4a01      	ldr	r2, [pc, #4]	; (98 <PVD_handler+0x8>)
  92:	4b02      	ldr	r3, [pc, #8]	; (9c <PVD_handler+0xc>)
  94:	601a      	str	r2, [r3, #0]
  96:	bf00      	nop
  98:	05fa0004 	.word	0x05fa0004
  9c:	e000ed0c 	.word	0xe000ed0c

000000a0 <RTC_handler>:
_default_handler(RTC_handler) // 2
  a0:	4a01      	ldr	r2, [pc, #4]	; (a8 <RTC_handler+0x8>)
  a2:	4b02      	ldr	r3, [pc, #8]	; (ac <RTC_handler+0xc>)
  a4:	601a      	str	r2, [r3, #0]
  a6:	bf00      	nop
  a8:	05fa0004 	.word	0x05fa0004
  ac:	e000ed0c 	.word	0xe000ed0c

000000b0 <TAMPER_handler>:
_default_handler(TAMPER_handler) // 3
  b0:	4a01      	ldr	r2, [pc, #4]	; (b8 <TAMPER_handler+0x8>)
  b2:	4b02      	ldr	r3, [pc, #8]	; (bc <TAMPER_handler+0xc>)
  b4:	601a      	str	r2, [r3, #0]
  b6:	bf00      	nop
  b8:	05fa0004 	.word	0x05fa0004
  bc:	e000ed0c 	.word	0xe000ed0c

000000c0 <FLASH_handler>:
_default_handler(FLASH_handler) // 4
  c0:	4a01      	ldr	r2, [pc, #4]	; (c8 <FLASH_handler+0x8>)
  c2:	4b02      	ldr	r3, [pc, #8]	; (cc <FLASH_handler+0xc>)
  c4:	601a      	str	r2, [r3, #0]
  c6:	bf00      	nop
  c8:	05fa0004 	.word	0x05fa0004
  cc:	e000ed0c 	.word	0xe000ed0c

000000d0 <RCC_handler>:
_default_handler(RCC_handler) // 5
  d0:	4a01      	ldr	r2, [pc, #4]	; (d8 <RCC_handler+0x8>)
  d2:	4b02      	ldr	r3, [pc, #8]	; (dc <RCC_handler+0xc>)
  d4:	601a      	str	r2, [r3, #0]
  d6:	bf00      	nop
  d8:	05fa0004 	.word	0x05fa0004
  dc:	e000ed0c 	.word	0xe000ed0c

000000e0 <EXTI0_handler>:
_default_handler(EXTI0_handler) // 6
  e0:	4a01      	ldr	r2, [pc, #4]	; (e8 <EXTI0_handler+0x8>)
  e2:	4b02      	ldr	r3, [pc, #8]	; (ec <EXTI0_handler+0xc>)
  e4:	601a      	str	r2, [r3, #0]
  e6:	bf00      	nop
  e8:	05fa0004 	.word	0x05fa0004
  ec:	e000ed0c 	.word	0xe000ed0c

000000f0 <EXTI1_handler>:
_default_handler(EXTI1_handler) // 7
  f0:	4a01      	ldr	r2, [pc, #4]	; (f8 <EXTI1_handler+0x8>)
  f2:	4b02      	ldr	r3, [pc, #8]	; (fc <EXTI1_handler+0xc>)
  f4:	601a      	str	r2, [r3, #0]
  f6:	bf00      	nop
  f8:	05fa0004 	.word	0x05fa0004
  fc:	e000ed0c 	.word	0xe000ed0c

00000100 <EXTI2_handler>:
_default_handler(EXTI2_handler) // 8
 100:	4a01      	ldr	r2, [pc, #4]	; (108 <EXTI2_handler+0x8>)
 102:	4b02      	ldr	r3, [pc, #8]	; (10c <EXTI2_handler+0xc>)
 104:	601a      	str	r2, [r3, #0]
 106:	bf00      	nop
 108:	05fa0004 	.word	0x05fa0004
 10c:	e000ed0c 	.word	0xe000ed0c

00000110 <EXTI3_handler>:
_default_handler(EXTI3_handler) // 9
 110:	4a01      	ldr	r2, [pc, #4]	; (118 <EXTI3_handler+0x8>)
 112:	4b02      	ldr	r3, [pc, #8]	; (11c <EXTI3_handler+0xc>)
 114:	601a      	str	r2, [r3, #0]
 116:	bf00      	nop
 118:	05fa0004 	.word	0x05fa0004
 11c:	e000ed0c 	.word	0xe000ed0c

00000120 <EXTI4_handler>:
_default_handler(EXTI4_handler) // 10
 120:	4a01      	ldr	r2, [pc, #4]	; (128 <EXTI4_handler+0x8>)
 122:	4b02      	ldr	r3, [pc, #8]	; (12c <EXTI4_handler+0xc>)
 124:	601a      	str	r2, [r3, #0]
 126:	bf00      	nop
 128:	05fa0004 	.word	0x05fa0004
 12c:	e000ed0c 	.word	0xe000ed0c

00000130 <DMA1CH1_handler>:
_default_handler(DMA1CH1_handler) // 11
 130:	4a01      	ldr	r2, [pc, #4]	; (138 <DMA1CH1_handler+0x8>)
 132:	4b02      	ldr	r3, [pc, #8]	; (13c <DMA1CH1_handler+0xc>)
 134:	601a      	str	r2, [r3, #0]
 136:	bf00      	nop
 138:	05fa0004 	.word	0x05fa0004
 13c:	e000ed0c 	.word	0xe000ed0c

00000140 <DMA1CH2_handler>:
_default_handler(DMA1CH2_handler) // 12
 140:	4a01      	ldr	r2, [pc, #4]	; (148 <DMA1CH2_handler+0x8>)
 142:	4b02      	ldr	r3, [pc, #8]	; (14c <DMA1CH2_handler+0xc>)
 144:	601a      	str	r2, [r3, #0]
 146:	bf00      	nop
 148:	05fa0004 	.word	0x05fa0004
 14c:	e000ed0c 	.word	0xe000ed0c

00000150 <reset_mcu>:

void __attribute__((naked)) reset_mcu(){
// réinitialise le µC
	_reset_mcu();
 150:	4a01      	ldr	r2, [pc, #4]	; (158 <reset_mcu+0x8>)
 152:	4b02      	ldr	r3, [pc, #8]	; (15c <reset_mcu+0xc>)
 154:	601a      	str	r2, [r3, #0]
 156:	bf00      	nop
 158:	05fa0004 	.word	0x05fa0004
 15c:	e000ed0c 	.word	0xe000ed0c

00000160 <startup>:
    (unsigned int *)  reset_mcu, // 59 DMA2CH4_5
};


void startup()
{
 160:	b508      	push	{r3, lr}
    /* Set memory in bss segment to zeros */
    unsigned int * bss_start_p = &_BSS_START; 
    unsigned int * bss_end_p = &_BSS_END;

    while(bss_start_p != bss_end_p)
 162:	4b19      	ldr	r3, [pc, #100]	; (1c8 <startup+0x68>)
 164:	4a19      	ldr	r2, [pc, #100]	; (1cc <startup+0x6c>)
 166:	429a      	cmp	r2, r3
 168:	d00b      	beq.n	182 <startup+0x22>
 16a:	1d13      	adds	r3, r2, #4
 16c:	4a16      	ldr	r2, [pc, #88]	; (1c8 <startup+0x68>)
 16e:	1ad2      	subs	r2, r2, r3
 170:	f022 0203 	bic.w	r2, r2, #3
 174:	441a      	add	r2, r3
 176:	3b04      	subs	r3, #4
    {
        *bss_start_p = 0;
 178:	2100      	movs	r1, #0
 17a:	f843 1b04 	str.w	r1, [r3], #4
{
    /* Set memory in bss segment to zeros */
    unsigned int * bss_start_p = &_BSS_START; 
    unsigned int * bss_end_p = &_BSS_END;

    while(bss_start_p != bss_end_p)
 17e:	4293      	cmp	r3, r2
 180:	d1fb      	bne.n	17a <startup+0x1a>
     * read/write memory */
    unsigned int * data_rom_start_p = &_DATA_ROM_START;
    unsigned int * data_ram_start_p = &_DATA_RAM_START;
    unsigned int * data_ram_end_p = &_DATA_RAM_END;

    while(data_ram_start_p != data_ram_end_p)
 182:	4b13      	ldr	r3, [pc, #76]	; (1d0 <startup+0x70>)
 184:	4a13      	ldr	r2, [pc, #76]	; (1d4 <startup+0x74>)
 186:	429a      	cmp	r2, r3
 188:	d00d      	beq.n	1a6 <startup+0x46>
 18a:	4a13      	ldr	r2, [pc, #76]	; (1d8 <startup+0x78>)
 18c:	4b13      	ldr	r3, [pc, #76]	; (1dc <startup+0x7c>)
 18e:	4810      	ldr	r0, [pc, #64]	; (1d0 <startup+0x70>)
 190:	1ac0      	subs	r0, r0, r3
 192:	f020 0003 	bic.w	r0, r0, #3
 196:	4418      	add	r0, r3
 198:	3b04      	subs	r3, #4
    {
        *data_ram_start_p = *data_rom_start_p;
 19a:	f852 1b04 	ldr.w	r1, [r2], #4
 19e:	f843 1b04 	str.w	r1, [r3], #4
     * read/write memory */
    unsigned int * data_rom_start_p = &_DATA_ROM_START;
    unsigned int * data_ram_start_p = &_DATA_RAM_START;
    unsigned int * data_ram_end_p = &_DATA_RAM_END;

    while(data_ram_start_p != data_ram_end_p)
 1a2:	4283      	cmp	r3, r0
 1a4:	d1f9      	bne.n	19a <startup+0x3a>
        *data_ram_start_p = *data_rom_start_p;
        data_ram_start_p++;
        data_rom_start_p++;
    }
    // active les interruptions et les fault handler
    __enable_irq();
 1a6:	b662      	cpsie	i
    __enable_fault_irq();
 1a8:	b661      	cpsie	f
    // initialisaton de la pile PSP et commutation 
    // vers cette pile.
    asm volatile(
 1aa:	4b0d      	ldr	r3, [pc, #52]	; (1e0 <startup+0x80>)
 1ac:	4618      	mov	r0, r3
 1ae:	f380 8809 	msr	PSP, r0
 1b2:	f3ef 8014 	mrs	r0, CONTROL
 1b6:	f040 0002 	orr.w	r0, r0, #2
 1ba:	f380 8814 	msr	CONTROL, r0
 1be:	f3bf 8f6f 	isb	sy
    "msr CONTROL,r0\n"
    "ISB\n"
    :: [psp_top] "r" (PSP_TOP)
    );
    /* Now we are ready to start the main function */
    main();
 1c2:	f7ff fffe 	bl	0 <main>
 1c6:	bd08      	pop	{r3, pc}
	...
 1dc:	00000004 	.word	0x00000004
 1e0:	20004c00 	.word	0x20004c00
